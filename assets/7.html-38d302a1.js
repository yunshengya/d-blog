const e=JSON.parse('{"key":"v-5093d43a","path":"/category/Vue/7.html","title":"Vue中的响应性语法糖已废弃","lang":"zh-CN","frontmatter":{"title":"Vue中的响应性语法糖已废弃","lang":"zh-CN","date":"2022-02-15T00:00:00.000Z","author":"橙猫猫","category":["Vue"],"tag":["Vue"],"description":"介绍 自从引入组合式 API 的概念以来，一个主要的未解决的问题就是 ref 和 reactive 到底用哪个。reactive 存在解构丢失响应性的问题，而 ref 需要到处使用 .value 则感觉很繁琐，并且在没有类型系统的帮助时很容易漏掉 .value。 例如，下面的计数器： &lt;template&gt; &lt;button @click=\\"increment\\"&gt;{{ count }}&lt;/button&gt; &lt;/template&gt;","head":[["meta",{"property":"og:url","content":"https://f9b95251.d-blog-et7.pages.dev/category/Vue/7.html"}],["meta",{"property":"og:site_name","content":"橙猫猫"}],["meta",{"property":"og:title","content":"Vue中的响应性语法糖已废弃"}],["meta",{"property":"og:description","content":"介绍 自从引入组合式 API 的概念以来，一个主要的未解决的问题就是 ref 和 reactive 到底用哪个。reactive 存在解构丢失响应性的问题，而 ref 需要到处使用 .value 则感觉很繁琐，并且在没有类型系统的帮助时很容易漏掉 .value。 例如，下面的计数器： &lt;template&gt; &lt;button @click=\\"increment\\"&gt;{{ count }}&lt;/button&gt; &lt;/template&gt;"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-18T07:38:26.000Z"}],["meta",{"property":"article:author","content":"橙猫猫"}],["meta",{"property":"article:tag","content":"Vue"}],["meta",{"property":"article:published_time","content":"2022-02-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-18T07:38:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue中的响应性语法糖已废弃\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-02-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-18T07:38:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"橙猫猫\\"}]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"配置","slug":"配置","link":"#配置","children":[]},{"level":2,"title":"已废弃的实验性功能","slug":"已废弃的实验性功能","link":"#已废弃的实验性功能","children":[]},{"level":2,"title":"废弃原因","slug":"废弃原因","link":"#废弃原因","children":[{"level":3,"title":"理由","slug":"理由","link":"#理由","children":[]},{"level":3,"title":"迁移计划","slug":"迁移计划","link":"#迁移计划","children":[]},{"level":3,"title":"留言","slug":"留言","link":"#留言","children":[]},{"level":3,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}]}],"git":{"createdTime":1763451506000,"updatedTime":1763451506000,"contributors":[{"name":"dz","email":"15226081387@163.com","commits":1}]},"readingTime":{"minutes":6.22,"words":1867},"filePathRelative":"category/Vue/7.md","localizedDate":"2022年2月15日","excerpt":"<h2> 介绍</h2>\\n<hr>\\n<p>自从引入组合式 API 的概念以来，一个主要的未解决的问题就是 <code>ref</code> 和 <code>reactive</code> 到底用哪个。<code>reactive</code> 存在解构丢失响应性的问题，而 <code>ref</code> 需要到处使用 <code>.value</code> 则感觉很繁琐，并且在没有类型系统的帮助时很容易漏掉 <code>.value</code>。</p>\\n<p>例如，下面的计数器：</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>&lt;template&gt;\\n  &lt;button @click=\\"increment\\"&gt;{{ count }}&lt;/button&gt;\\n&lt;/template&gt;\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
